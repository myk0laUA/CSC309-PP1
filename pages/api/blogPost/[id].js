import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient(); 

export default async function handler(req, res) {
    if (req.method === "PUT") {
        const { id } = req.query;

        if (!id) {
            return res.status(400).json({ message: 'Blog Post ID is required '});

        }

        const { title, description, tags, linkToTemplates } = req.body;

        const existingBlogPost = await prisma.blogPost.findUnique({
            where: { id: parseInt(id) },
        });

        if (!existingBlogPost) {
            return res.status(400).json({ message: "Blog Post Not Found"});
        }

        const blogPost = await prisma.blogPost.update({
            where: {id: parseInt(id) },
            data: {
                title: title || existingBlogPost.title,
                description: description || existingBlogPost.description,
                tags: tags || existingBlogPost.tags,
                linkToTemplates: linkToTemplates || existingBlogPost.linkToTemplates,

            },
        });

        return res.status(200).json(blogPost);

    // generated by ChatGPT    
    } else if (req.method === "PATCH") {

        const { voteType } = req.body;

        const existingBlogPost = await prisma.blogPost.findUnique({
            where: { id: parseInt(id) },
        });

        if (!existingBlogPost) {
            return res.status(400).json({ message: "Blog Post Not Found" });
        }

        let updatedBlogPost;

        if (voteType === 'upvote') {
            updatedBlogPost = await prisma.blogPost.update({
                where: { id: parseInt(id) },
                data: {
                    upvotes: updatedBlogPost.upvotes + 1,
                    rating: updatedBlogPost.rating = updatedBlogPost.upvotes - updatedBlogPost.downvotes,
                },
            });

        } else if (voteType === 'downvote') {
            updatedBlogPost = await prisma.blogPost.update({
                where: { id: parseInt(id) },
                data: {
                    downvotes: updatedBlogPost.downvotes + 1,
                    rating: updatedBlogPost.rating = updatedBlogPost.upvotes - updatedBlogPost.downvotes,
                },
            });

        } else {

            return res.status(400).json({ message: "Invalid vote type" });
        }

        return res.status(200).json(updatedBlogPost);


    } else if (req.method === "DELETE") {

        const { id } = req.query;

        if (!id) {
            return res.status(400).json({ message: 'Blog Post ID is required '});

        }

        const { title, description, tags, linkToTemplates } = req.body;

        const existingBlogPost = await prisma.blogPost.findUnique({
            where: { id: parseInt(id) },
        });

        await client.blogPost.delete({
            where: { id: parseInt(id) },
        });

        return res.status(200).json({ message: "Blog Post deleted"} )


    } else {
        
        res.status(405).json({ message: "Method not allowed" });

    }
}
